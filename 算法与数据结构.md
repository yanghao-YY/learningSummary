# 8.30 第1节 认识复杂度、对数器、二分法、异或运算

动态规划、树形DP

**时间复杂度 （发生了多少次常数时间操作）**

**额外空间复杂度**

**常数项时间 （与数据量无关，数组寻址）**O(1)

```java
>>  带符号右移   >>>  不带符号右移
算术运算、
赋值、比较、自增、自减
数组寻址
```

时间复杂度：只要高阶项  只与数据量有关

流程拆分，基本动作都是常数操作

选择、冒泡、插入时间复杂度 O(N^2)  空间复杂度O(1)

选择排序：最小值放最左边 0~n-1, 1~n-1   

从数组中选取最小的数放到最左边  外层一次循环只交换一次，内层比较大小寻找最小值的下标

冒泡排序：比较相邻的两个值 满足就交换，外层控制遍历次数，内层控制比较交换

插入排序：数据情况会影响算法时间复杂度 最低O(N)

0 ~ 0上有序、0 ~ i上有序

等差数列：O(N^2)

``额外空间复杂度``

作为输入和输出的不算额外空间

最优解

O(1)>O(logN)>O(N)>O(N*logN)>O(N^2)>O(2^N)>O(N!)

递归能力（怎么试的算法）

**对数器**

测试调试

**二分法**

01节1h27m

局部最小（无序二分）函数趋势

异或运算（无进位相加）

0 ^ N == N   N ^ N == 0

异或满足交换律和结合律

两值交换，内存不一样  不然a ^ a ^ a ^ a = 0

# **9.5 第2节 链表结构、栈、队列、递归行为、哈希表和有序表**

面试题   千锤百炼，给面试者干

念叨  钻研人性

单向链表

```java
class Node{
	int value;
	node next
 }
```

双向链表

```java
class DoubleNode{
    int value;
    DoubleNode last;
    DoubleNode next;
}
```

**练习**：1.反转、2.删除给定值

考虑头部删除

java c++内存释放  （能够被活着的引用找到的对象不被回收）

栈：数据先进后出，弹匣  

队列：数据先进先出

栈和队列实际实现。双向链表，数组  **练习**（双向链表实现栈和队列，数组实现栈和队列）

双指针怎么改

数组实现队列：内存循环使用   **练习**

栈最小值： **练习**   O(1)

栈实现队列、队列实现栈  **练习**

图  宽度  ->  队列  深度 -> 栈

**递归**

递归利用系统栈  （base case）

系统栈等待运行状态  用栈遍历图 系统栈空间参数（可以调整优化）

任何递归都可以改为非递归。递归改为迭代 -> 尾

递归脑图

master公式  等规模子范围递归复杂度公式

T(N) = a * T(N/b) + O(N^d)   a,b,d都是常数。 d为除开递归之外其他代码的复杂度。

1).log(b)a  > d 复杂度O(N^log(b)a)

2).log(b)a < d 复杂度O(N^d)

3).log(b)a = d 复杂度O(N^d * logN)

**哈希表 ** **HashMap ** O(1)

哈希表  增删改查  都是O(1)

哈希表  引用传递和值传递

Integer ~128 - 127  按值传递

哈希表基础类型（不管是不是包装类型）一律按值传递

String?  是引用类型，在hash表里是值

**有序表 ** **TreeMap**  O(logN)

按Key排序

LinkedHashMap  按放入顺序排序

加入非基础类型  比较器

AVL  SB  红黑树  (自带平衡属性的二叉树) 

跳表



# 9.12 第3节：归并排序  快排

归并排序，快速排序  O(N * log N)

归并排序：merge的过程。空间复杂度 O(N)

快速排序：小于区，等于区，大于区。空间复杂度 O(log N)

荷兰国旗问题



# 9.19 第4节：堆、堆排序

一次性的数组，可以使用大根堆优化，从右到左heapify

无递归，空间复杂度O(1)，时间复杂度O(N*logN)

堆：大根堆，小根堆

系统堆：PriorityQueue  默认小根堆

比较器应用

resign  堆结构超级重要

第五节：trie、桶排序、排序总结

前缀树  pass、end  可以拓展我们实际想要的属性

字符种类多，使用hashmap



**不基于比较的排序**

**桶排序**：桶就是一个容器、一个萝卜一个坑  范围很窄  和数据状况本身强相关。一种思想，用容器来排序

​	计数排序：词频统计 O(N)  

​	基数排序：非负，且满足10进制

# 第5节 trie、桶排序、排序总结

# 第6节 链表相关面试题

字笔写代码 练习：(不同类型题目20道 每种2道 留20道专门手写)

链表问题：

1.对于笔试，不用太在乎空间复杂度，一切为了时间复杂度

2.对于面试，时间复杂度依然放在第一位，但是一定要找到空间最省的方法

**快慢指针**

链表问题 codeing没有小事 培养思考

作业：4个链表中点

回文 栈

partition 链表是稳定的。数组不稳定

链表注意考虑额外空间



一个有环一个无环不可能相交

2个都有环相交一定共用这个环

​	1.入环同一个点

​	2.入环不是同一个点

不给头节点 只给删除节点 怎么删除？此题无解。必须要头节点

​	1.抖机灵的方式，用下一个对象覆盖当前对象。存在问题 

约瑟夫环

**练习**

# 第7节 二叉树基本算法

树形DP

二叉树，先序、中序、后序遍历

先序：  唯一，头左右

中序：左头右	

后序：左右头

遍历：每个子树的遍历顺序

递归序加工的结果  先中后序  看你在第几次到达节点时打印

任何递归函数都可以改为非递归  -> 压栈的方式实现

**自己设计压栈**

整棵树可以完全被左边界分解掉

深度优先遍历：

宽度优先遍历（按层遍历）：队列

题目：**统计二叉树最大宽度？**发现层的机制

1.使用map

2.不使用map

题目：**二叉树的序列化和反序列化？**

1.先，中，后，层遍历都可以  注意补null，补上null节点，用什么序列化就用什么反序列化

序列化和结构一一对应

# 第8节：二叉树的递归套路(很值钱)

题目：如何设计一个打印整棵树的打印函数

题目：

```java
class Node{
    V value;
    Node left;
    Node right;
    Node parent;
}
给你一个二叉树中的某个节点，返回该节点的后继节点。
```

后继节点：中序遍历序列中，某个节点的后面一个节点就是后继节点

前驱节点：中序遍历序列中，某个节点的前面一个节点就是前驱节点

递归序时间复杂度：每个节点到达3次  O(n)

调研某个节点与后继节点的结构关系

1.有右树

2.无右树

3.最右节点

题目：请把一段纸条竖着放在桌子上，然后从纸条的下边向上方对折1次，压出折痕后展开。此时折痕是凹下去的，即折痕突起的方向指向纸条的背面。如果从纸条的下边向上方对折2次，压出折痕后展开，此时有三条折痕，从上到下依次是下折痕，下折痕和上折痕。

给定一个输入参数N，代表纸条都从下边向上方连续对折N次。请从上到下打印所有折痕的方向。例如N=1时，打印：down。 N=2时，打印：down down up

算法模型敏感度

主线：1.二叉树的递归套路、2.暴力递归改动态规划

二叉树的递归套路：树上做动态规划，空间换时间。树形DP问题

DP(Dynamic Programing) 动态规划

**平衡二叉树：**

​	1.二叉树中左右子树的高度差不超过1。

​	2.左树、右树都是平衡树。

题目：给一个节点判断以这个节点为头的二叉树是否平衡？

题目：给定一颗二叉树的头节点head，任何两个节点之间都存在距离，返回整棵二叉树的最大距离。

​	最大距离可能性，（常见分类）是否与X有关系

​	1.无关：左树上最大或者右树上最大。

​	2.有关：左树上离X最远的点(左树的高度)到右树上离X最远的点(右树的高度)。

信息整合：高度，最大距离

**搜索二叉树：**

​	1.左树都比头节点小，右树都比节点大。没有重复节点

题目：给定一个节点，求该节点为头的二叉树上最大搜索二叉树的节点个数？

**威力无穷**

题目：

派对的最大快乐值

```java
//员工信息的定义如下：上下级
class Employee{
    public int happy;//这名员工可以带来的快乐值
    List<Employee> subordinates;//这名员工有哪些直接下级
}
```

标准的多叉树

递归每个节点最多到达三次

**满二叉树**：每一层的节点都是满的

高度L  节点N  2^L - 1 = N

题目：判断一个棵树是否是满二叉树

题目：给定一棵二叉树的头节点head  返回这颗二叉树中最大的二叉搜说子树的头节点。（大小）

题目：判断一棵树是否是完全二叉树

**完全二叉树**：二叉树节点从左到右依次变满

1.有右无左 false

2.第一个左右孩子不双全的节点之后的节点都是叶子节点 true

二叉树递归套路解：

题目：给定一颗二叉树的头节点head,和另外两个节点a和b。返回a和b的最低公共祖先

# 10.15 第9节 贪心算法

# 第10节 并查集结构和图相关算法

图：点集和边集  表达图的方式很多    边有权重  有方向

图的宽度优先遍历（队列  set  图可能有环）和深度优先遍历（栈）

拓扑排序：无环图  消除入度为0的点

最小生成树算法 

​	Kruskal K算法  ：用并查集 

​	P算法：不需要并查集

# 第11节 暴力递归

# 第12节 动态规划

# 第13节 暴力递归到动态规划1

中序遍历序列化无法反序列化

# 第14节 暴力递归到动态规划2

鳄鱼吃人

海盗分金币 ABCDE  投票通过？得到金币的时候选择杀人还是不杀人

欧拉信封

N皇后问题

语义：（主函数为什么这么调？）

​		   （还原现场）

优化常数项时间  位运算  <<     >>      >>> 无符号右移

怎么尝试一件事情？

经典：斐波那契数列 

暴力递归有大量重复计算  -> 改成动态规划

动态规划 -> 记忆化搜索

所有的动态规划都可以来自一个暴力递归

某些暴力递归改不成动态规划

参数组合玩成结构化的缓存 -> 动态规划

# 第15节 暴力递归到动态规划3

暴力递归改动态规划和原始题意解耦

递归过程映射成表

范围尝试  表中有位置不用

return的地方就是需要保存值  （写入动态规划表的地方）

记忆化搜索不讲究组织

经典动态规划精细的组织结构

在递归过程没有枚举的时候两者时间复杂度一致。

有时候需要再进一步优化记忆化搜索  动态规划转移方程优化

# 第16节 暴力递归到动态规划4

可变参数能少则少