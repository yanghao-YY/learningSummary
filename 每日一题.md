# 第一章 栈和队列

## 2021/07/05 两个栈实现队列

```java
/**
 * @Auther: licl
 * @Date: 2021/07/05
 * @Description: 问题：两个栈实现队列  支持队列的基本操作 add  poll  peek
 *               思路：栈的特点是先进后出，队列是先进先出  所以用2个栈刚好可以把顺序调过来  具体实现是注意倒出倒入的时候 栈的状态
 * @version: 1.0
 */
public class TwoStacksImplementQueue {

    public static class MyQueue{
        private Stack<Integer> pushStack;
        private Stack<Integer> popStack;

        public MyQueue(){
            this.pushStack = new Stack<>();
            this.popStack = new Stack<>();
        }

        //add
        public void add(int value){
            pushStack.push(value);
        }
        //poll
        // 思维误区  因为是从一开始就控制pushStack必须一次性倒完 所以不会存在 pushStack 和 popStack都存在数据的情况
        public int poll(){
            //poll时
            // 1、pushStack必须一次性把数据往popStack倒完
            // 2、popStack不为空时不能往popStack倒数据
            if(this.popStack.isEmpty() && this.pushStack.isEmpty()){
                throw new RuntimeException("Queue is Empty!");
            } else if(this.popStack.isEmpty()){
                //可以往popStack倒数据,必须一次性倒完
                while (!this.pushStack.isEmpty()){
                    this.popStack.push(this.pushStack.pop());
                }
            }
            //倒完之后 或者 原本有数据  弹出
            return this.popStack.pop();
        }

        //peek
        public int peek(){
            if(this.popStack.isEmpty() && this.pushStack.isEmpty()){
                throw new RuntimeException("Queue is Empty!");
            } else if(this.popStack.isEmpty()){
                while (!this.pushStack.isEmpty()){
                    this.popStack.push(this.pushStack.pop());
                }
            }
            return this.popStack.peek();
        }

        public boolean isEmpty(){
            return this.pushStack.isEmpty() && this.popStack.isEmpty();
        }
    }

    public static void main(String[] args) {
        MyQueue myQueue = new MyQueue();
        myQueue.add(2);
        myQueue.add(4);
        myQueue.add(1);
        myQueue.add(3);
        myQueue.add(5);
        while (!myQueue.isEmpty()){
            System.out.println(myQueue.poll());
        }
    }

}
```

## 2021/07/05 两个队列实现栈

```java
/**
 * @Auther: licl
 * @Date: 2020/07/05
 * @Description: 问题：两个队列实现栈  支持栈的基本操作 push  pop  peek
 *               思路：用2个队列queue和help 每次pop的时候  queue队列保留一个数  将其他数放到help队列 然后将queue保留的数弹出 两个队列角色互换 重复
 * @version: 1.0
 */
public class TwoQueuesImplementStack {

    public static class MyStack<T> {
        public Queue<T> queue;
        public Queue<T> help;
        public MyStack(){
            queue = new LinkedList();
            help = new LinkedList<>();
        }
        // push
        public void push(T t){
            queue.add(t);
        }
        // pop
        public T pop() {
            // 往help队列转移除最后一个数的其他数据
            while (queue.size() > 1){
                help.add(queue.poll());
            }
            T ans = queue.poll();
            // 然后转换角色
            Queue<T> temp = queue;
            queue = help;
            help = temp;
            return ans;
        }

        // peek
        public T peek() {
            // 往help队列转移除最后一个数的其他数据
            while (queue.size() > 1){
                help.add(queue.poll());
            }
            T ans = queue.poll();
            // peek注意将最后一个数也加入到help
            help.add(ans);
            // 然后转换角色
            Queue<T> temp = queue;
            queue = help;
            help = temp;
            return ans;
        }

        public boolean isEmpty(){
            return this.queue.isEmpty() && this.help.isEmpty();
        }

    }

	//for test
    public static void main(String[] args) {
        MyStack myStack = new MyStack();
        myStack.push(2);
        myStack.push(4);
        myStack.push(1);
        myStack.push(3);
        myStack.push(5);
        System.out.println(myStack.pop());
        System.out.println(myStack.pop());
        System.out.println(myStack.pop());
        myStack.push(99);
        System.out.println(myStack.pop());
        System.out.println(myStack.pop());
        System.out.println(myStack.pop());
    }


}
```

## **2021/07/06** 实现可以获取最小值的栈

```java
/**
 * @Auther: licl
 * @Date: 2021/07/06
 * @Description: 问题：实现一个特殊的栈，在实现栈的基本功能的同时，再实现返回栈中最小元素的操作
 *                 要求：1.pop push getMin操作的时间复杂度都是O(1)
 *                     2.设计的栈类型可以使用现成的栈结构。
 *               思路：使用2个栈，一个栈记录正常数据，另一个栈记录最小值。
 * @version: 1.0
 */
public class GetMinStack {

    //第一种方法  同步压入数据栈和最小值栈  压入的时候进行最小值栈压入值的判断  弹出的时候节省时间  增加了空间量 O(n)
    public static class MyStack1 {
        private Stack<Integer> stack;
        private Stack<Integer> minStack;

        public MyStack1(){
            this.stack = new Stack<>();
            this.minStack = new Stack<>();
        }

        //push方法
        public void push(int value){
            if(this.minStack.isEmpty()){
                this.minStack.push(value);
            } else if(value <= this.getMin()){
                //新加入的数小 minStack压入value
                this.minStack.push(value);
            } else {
                //新加入数大 minStack压入之前的最小值 栈顶
                this.minStack.push(this.getMin());
            }
            this.stack.push(value);
        }

        //pop
        public int pop(){
            if(this.stack.isEmpty()){
                throw new RuntimeException("Your stack is empty!");
            }
            //弹出的时候同步弹出
            this.minStack.pop();
            return this.stack.pop();
        }

        //获取最小值
        public int getMin() {
            if(this.minStack.isEmpty()){
                throw new RuntimeException("Your stack is empty!");
            }
            return this.minStack.peek();
        }
    }

    //第二种方法   不同步压入最小值栈和数据栈，仅当新加入的数比最小值栈栈顶数小的时候压入  节省了空间，  弹出的时候需要增加判断的时间
    public static class MyStack2{
        private Stack<Integer> stack;
        private Stack<Integer> minStack;

        public MyStack2(){
            this.stack = new Stack<>();
            this.minStack = new Stack<>();
        }

        //push
        public void push(int value){
            if(this.minStack.isEmpty()){
                this.minStack.push(value);
            } else if(value <= this.getMin()){
                //当前数小于等于时  压入当前数
                this.minStack.push(value);
            } else {
                //当前数大  不压入
            }
            this.stack.push(value);
        }

        //pop
        public int pop(){
            //弹出的时候需要进行判断  当stack弹出的数和getMin相等时  minStack弹出
            if(this.stack.isEmpty()){
                if(this.minStack.isEmpty()){
                    throw new RuntimeException("Your stack is empty!");
                }
            }
            int value = this.stack.pop();
            if(value == this.getMin()){
                this.minStack.pop();
            }
            return value;
        }

        public int getMin() {
            if(this.minStack.isEmpty()){
                throw new RuntimeException("Your stack is empty!");
            }
            return this.minStack.peek();
        }
    }

        // for test
        public static void main(String[] args) {
        MyStack2 myStack1 = new MyStack2();
        myStack1.push(3);
        myStack1.push(4);
        myStack1.push(5);
        myStack1.push(1);
        myStack1.push(2);
        myStack1.push(1);
//        myStack1.push(5);
        System.out.println(myStack1.getMin());
            System.out.println(myStack1.pop());
            System.out.println("----------------");
        System.out.println(myStack1.getMin());
            System.out.println(myStack1.pop());
            System.out.println("----------------");
        System.out.println(myStack1.getMin());
            System.out.println(myStack1.pop());
            System.out.println("----------------");
        System.out.println(myStack1.getMin());
            System.out.println(myStack1.pop());
            System.out.println("----------------");
        System.out.println(myStack1.getMin());
            System.out.println(myStack1.pop());
            System.out.println("----------------");
        System.out.println(myStack1.getMin());
            System.out.println(myStack1.pop());
    }


}
```

## **2021/07/06** 用一个栈实现另一个栈的排序

```java
题目：一个栈中的元素为整型，现在想将该栈从顶到底按从大到小的顺序排序，只许申请一个栈。除此之外，可以申请新的变量，但不能申请额外的数据结构，如何完成排序？
    -----------------------------------------------
解答：
    /**
 * @Auther: licl
 * @Date: 2021/07/06
 * @Description:  用一个栈实现另一个栈的排序
 *                一个栈中元素为整型，现在需要从顶到底安照从大到小排序，只可以申请一个栈，可以申请新的变量，但是不能申请额外的数据结构 完成排序
 *                思想：stack  help  stack弹出元素记做cur
 *                      1.如果cur小于等于help栈顶元素  则放入help
 *                      2.如果cur大于help栈顶元素 则弹出help元素放入stack 直到cur小于等于help栈顶元素  放入cur到help 继续从stack重复操作
 * @version: 1.0
 */
public class SortStackByStack {

    public void SortStackByStack(Stack<Integer> stack){
        Stack<Integer> help = new Stack();
        while (!stack.isEmpty()){
            int cur = stack.pop();
            while (!help.isEmpty() && cur > help.peek()){
                stack.push(help.pop());
            }
            help.push(cur);
        }
        while (!help.isEmpty()){
            stack.push(help.pop());
        }
    }

    public static void main(String[] args) {
        SortStackByStack ss = new SortStackByStack();
        Stack stack = new Stack();
        stack.push(1);
        stack.push(5);
        stack.push(3);
        stack.push(2);
        stack.push(4);
        stack.push(1);
        ss.SortStackByStack(stack);
        while (!stack.isEmpty()){
            System.out.println(stack.pop());
        }
    }

}
```

## 2021/07/07 数的最小和

```java
题目：在一个数组中，一个数左边比它小的数的总和，叫数的小和，所有数的小和累加起来，叫数组小和。求数组小和。
例子： [1,3,4,2,5] 
1左边比1小的数：没有
3左边比3小的数：1
4左边比4小的数：1、3
2左边比2小的数：1
5左边比5小的数：1、3、4、 2
所以数组的小和为1+1+3+1+1+3+4+2=16
```

## 2021/07/07 猫狗队列

```java
问题：宠物、狗、猫的类如下：
   public static class Pet{
        private String type;
        public Pet(String type){
            this.type = type;
        }
        public String getType(){
            return this.type;
        }
    }

    public static class Cat extends Pet{
        public Cat() {
            super("Cat");
        }
    }

    public static class Dog extends Pet{
        public Dog() {
            super("Dog");
        }
    }
实现一种猫狗队列的结构，要求如下：
    1.用户可以调用add方法将cat类或dog类的实例放入队列中；
    2.用户可以调用pollAll方法，将队列中所有的实例按照进队列的先后顺序依次弹出；
    3.用户可以调用pollDog方法，将队列中Dog类的实例按照进队列的先后顺序依次弹出；
    4.用户可以调用pollCat方法，将队列中Cat类的实例按照进队列的先后顺序依次弹出；
    5.用户可以调用isEmpty方法，检查队列中是否还有Dog或Cat的实例；
    6.用户可以调用isDogEmpty方法，检查队列中是否还有Dog类的实例；
    7.用户可以调用isCatEmpty方法，检查队列中是否还有Cat类的实例；

package com.lcl.study.practice;

import java.util.Queue;

/**
 * @Auther: licl
 * @Description: 猫狗队列练习
 * @Date: 2021/07/07
 */
public class CatDogQueue {

    private Queue<PetEnterQueue> dogQueue;
    private Queue<PetEnterQueue> catQueue;
    private long count;

    public CatDogQueueTest(Queue<PetEnterQueue> dogQueue, Queue<PetEnterQueue> catQueue) {
        this.dogQueue = dogQueue;
        this.catQueue = catQueue;
        this.count = 0;
    }

    // add
    public void add(Pet pet){
        if("Cat".equals(pet.getType())){
            this.catQueue.add(new PetEnterQueue(pet, this.count++));
        } else if("Dog".equals(pet.getType())){
            this.dogQueue.add(new PetEnterQueue(pet, this.count++));
        } else {
            throw new RuntimeException("your pei is not dog or cat");
        }
    }

    // pollAll 弹出的时候变比较dogQueue的最前端元素的count和catQueue最前端元素的count哪个小 哪个先出
    public Pet pollAll(){
        if(!catQueue.isEmpty() && !dogQueue.isEmpty()){
            if(catQueue.peek().getCount() < dogQueue.peek().getCount()){
                return catQueue.poll().getPet();
            } else {
                return dogQueue.poll().getPet();
            }
        } else if(!catQueue.isEmpty()){
            return catQueue.poll().getPet();
        } else if(!dogQueue.isEmpty()){
            return dogQueue.poll().getPet();
        } else {
            throw new RuntimeException("your queue is empty!");
        }
    }

    public Pet pollCat(){
        if(!catQueue.isEmpty()){
            return catQueue.poll().getPet();
        } else {
            throw new RuntimeException("catQueu is empty!");
        }
    }

    public Pet pollDog(){
        if(!dogQueue.isEmpty()){
            return dogQueue.poll().getPet();
        } else {
            throw new RuntimeException("dogQueue is empty!");
        }
    }

    public boolean isDogQueueEmpty(){
        return dogQueue.isEmpty();
    }

    public boolean isCatQueueEmpty(){
        return catQueue.isEmpty();
    }

    public boolean isEmpty(){
        return catQueue.isEmpty() && dogQueue.isEmpty();
    }

    //定义一个新的类
    public static class PetEnterQueue{
        private Pet pet;
        private long count;  //记录入队的时间戳 用于出队时比较

        public PetEnterQueue(Pet pet, long count) {
            this.pet = pet;
            this.count = count;
        }

        public long getCount() {
            return count;
        }

        public Pet getPet() {
            return pet;
        }
        public String petEnterType(){
            return this.pet.getType();
        }
    }

    public static class Pet{
        private String type;
        public Pet(String type){
            this.type = type;
        }
        public String getType(){
            return this.type;
        }
    }

    public static class Cat extends CatDogQueue.Pet {
        public Cat() {
            super("Cat");
        }
    }

    public static class Dog extends CatDogQueue.Pet {
        public Dog() {
            super("Dog");
        }
    }

}

```

## **2021/07/07**  仅用递归逆序一个栈

```JAVA
/**
 * @Auther: licl
 * @Date: 2021/6/3
 * @Description: 问题：仅用递归函数和栈操作逆序一个栈 例如：一次压入 1、2、3 逆序之后变成 3、2、1
 *               思路：本题考查递归函数设计和栈的操作。利用递归程序压栈可以帮我们记录数据状态的特点实现
 *                          本题：设计2个递归函数
 *                               1.先思考如何移除栈的最后一个元素并返回
 *                               2.思考逆序递归要展开到最后一个，然后回溯才能容易理解
 */
public class ReverseStack {
    // 1.递归函数移除一个栈栈底的元素并返回
    public static int getAndRemoveLastElement(Stack<Integer> stack){
        int res = stack.pop(); //res作为每一次递归的中间变量，通过压栈的方式可以帮我们保存下来
        //base case
        if(stack.isEmpty()){
            return res;
        }
        //递归  递归函数执行完成之后会一层一层返回，每一层记录的res可以用于操作
        int last = getAndRemoveLastElement(stack);
        stack.push(res);
        return last;
        //
    }

    // 2.递归函数逆序一个栈
    public static void reverse(Stack<Integer> stack){
        //base case
        if(stack.isEmpty()){
            return;
        }
        int i = getAndRemoveLastElement(stack);
        //递归reverse  每次压栈会保存i的值
        reverse(stack);
        //当栈空了之后刚好是原来栈的栈顶返回
        stack.push(i);
    }

    public static void main(String[] args) {
        Stack stack = new Stack();
        stack.push(1);
        stack.push(2);
        stack.push(3);
        stack.push(4);
        stack.push(5);
        stack.push(6);
        reverse(stack);
        for (Object o : stack) {
            System.out.println(o);
        }
    }
```

# 第二章 链表

## 2021/07/09 打印两个有序链表的公共部分

```JAVA
题目：给定2个有序链表的头指针head1和head2，打印2个链表的公共部分
    package com.lcl.study.practice.linked;

/**
 * @Auther: licl
 * @Description: 打印两个有序链表的公共部分
 * @Date: 2021/07/09
 */
public class CommonNodePart {

    public static class Node{
        private int value;
        private Node next;
        public Node(int data){
            this.value = data;
        }
    }

    public static void main(String[] args) {
        Node head1 = new Node(1);
        Node n11 = new Node(3);
        Node n12 = new Node(5);
        Node n13 = new Node(7);
        Node n14 = new Node(8);

        head1.next = n11;
        head1.next.next = n12;
        head1.next.next.next = n13;
        head1.next.next.next.next = n14;
        // 1-3-5-7-8

        Node head2 = new Node(2);
        Node n21 = new Node(4);
        Node n22 = new Node(5);
        Node n23 = new Node(6);
        Node n24 = new Node(8);

        head2.next = n21;
        head2.next.next = n22;
        head2.next.next.next = n23;
        head2.next.next.next.next = n24;
        /*while (head1 != null){
            System.out.println(head1.value);
            head1 = head1.next;
        }
        System.out.println("================");
        while (head2 != null){
            System.out.println(head2.value);
            head2 = head2.next;
        }*/
        // 2-3-4-5-8
        printCommonPart(head1, head2);
    }

    private static void printCommonPart(Node head1, Node head2) {
        // 有序链表
        if(null == head1 || null == head2) return;
        while (null != head1 && null != head2){
            if(head1.value == head2.value){
                System.out.println(head1.value);
                head1 = head1.next;
                head2 = head2.next;
            } else if(head1.value < head2.value){
                head1 = head1.next;
            } else {
                head2 = head2.next;
            }
        }
    }


}
```

## 2021/07/09 判断一个链表是否为回文结构

题目：给定一个链表的头节点head,判断该链表是否为回文结构。
    例如：
    	1-2-1 返回true
    	1-2-2-1 返回true
    	1-2-3-1 返回false
    	1-2-3 返回false
    进阶：如果链表长度为N  要求时间复杂度O(N) 空间复杂度O(N)

```JAVA
package com.lcl.study.practice.linked;

import java.util.Stack;

/**
 * @Auther: licl
 * @Description: 判断一个链表是否为回文结构  1-2-1  1-2-2-1 1-2-3-1 false
 * @Date: 2021/7/12
 */
public class Palindrome {

    public static class Node{
        private int value;
        private Node next;
        public Node(int data){
            this.value = data;
        }
    }

    public static void main(String[] args) {
        Node head = new Node(1);
        Node n11 = new Node(2);
        Node n12 = new Node(3);
        Node n13 = new Node(3);
        Node n14 = new Node(2);
        Node n15 = new Node(1);

        head.next = n11;
        head.next.next = n12;
        head.next.next.next = n13;
        head.next.next.next.next = n14;
        head.next.next.next.next.next = n15;
        System.out.println(isPalindrom1(head));
        System.out.println(isPalindrom2(head));
    }
    

    // 方法2 利用栈，一半数据放入取出比较  1-2-3-2-1  取前N/2 1-2 和后N/2 2-1 将后一半压入栈
    private static boolean isPalindrom2(Node head) {
        //寻找后N/2的节点位置 快慢指针法
        if(head == null || head.next == null){
            return true;
        }
        // 寻找链表下中点
        Node right = head.next;
        Node cur = head;
        while (cur.next != null && cur.next.next != null){
            right = right.next;
            cur = cur.next.next;
        }
        Stack<Integer> stack = new Stack<>();
        while (right != null){
            stack.push(right.value);
            right = right.next;
        }
        while (!stack.isEmpty()){
            if(stack.pop() != head.value){
                return false;
            }
            head = head.next;
        }
        return true;
    }

    // 方法1 利用栈，全部数据放入取出比较
    private static boolean isPalindrom1(Node head) {
        Node cur = head;
        Stack<Integer> stack = new Stack();
        while (null != cur){
            stack.push(cur.value);
            cur = cur.next;
        }
        while (head != null){
            if(stack.pop() != head.value){
                return false;
            }
            head = head.next;
        }
        return true;
    }


}

```

## 2021/07/12 华为笔试题

题目：输入一个由数字组成的字符串逗号分隔，返回这些数字可以组成的最大值

例：输入："123,9,44,631"

​		返回：963144123

字符串由逗号分隔，不考虑数字无效的情况

```java
package com.lcl.study.practice.likou;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

/**
 * @Auther: licl
 * @Description: 字符串分隔，构成最大数  华为笔试题  当时用例通过只有90%+
 * @Date: 2021/7/13
 */
public class findBigNum {

    public static void main(String[] args) {

        /*Scanner sc = new Scanner(System.in);
        String str = sc.next();*/
        String str = "594,59";
//        String str = "09,909";
//        String str = "29,256";
//        String str = "9163,909";
//          String str = "59,594";
//          String str = "8329,832";
//        String str = "900,9009";
//        String str = "871,8718";  // 特殊用例
        System.out.println(test(str));



    }
    
     public static String test1(String str){
        String[] arr = str.split(",");
        List<String> list = Arrays.asList(arr);
        list.sort((o1, o2) -> Integer.valueOf(o2 + o1) - Integer.valueOf(o1 + o2));
        return list.stream().collect(Collectors.joining());
    }

    public static String test(String str){
        String[] arr = str.split(",");
        List<String> list = Arrays.asList(arr);
        list.sort((o1, o2) -> {
           /* o1 = Integer.valueOf(o1).toString();
            o2 = Integer.valueOf(o2).toString();*/
            if(o1.length() == o2.length()){
                // 长度相等，遍历返回最大
                return Integer.parseInt(o2) - Integer.parseInt(o1);
            } else {
                // 长度不相等，一位一位比较返回 (老思想)  直接拼接起来确认哪个在前数大 （新思想）
                return Integer.valueOf(o2 + o1) - Integer.valueOf(o1 + o2);

                // 之前一位一位比较的思想  MMP
                /*int len;
                if(o1.length() > o2.length()) len = o1.length();
                else len = o2.length();
                int k1 = -1;
                int k2 = -1;
                int h1 = -1;
                int h2 = -1;
                for (int i = 0; i < len; i++) {
                    if(o1.length() > i){
                        k1 = Integer.valueOf(o1.substring(i, i + 1));
                        if(i == 0){
                            h1 = k1;
                        }
                    } else {
                        k1 = h1;
                    }
                    if(o2.length() > i){
                        k2 = Integer.valueOf(o2.substring(i, i + 1));
                        if(i == 0){
                            h2 = k2;
                        }
                    } else {
                        k2 = h2;
                    }
                    if(k1 != k2){
                        break;
                    } else {
                        continue;
                    }
                }
                if(k1 != k2) return k2 - k1;
                else return Integer.valueOf(o2 + o1) - Integer.valueOf(o1 + o2);*/
            }
        });
        return list.stream().collect(Collectors.joining());
    }

}
```

## 2021/07/13 两数之和 （简单）

```java
package com.lcl.study.practice.likou;

import java.util.HashMap;
import java.util.Map;

/**
 * @Auther: licl
 * @Description: 两数之和  巧用map
 * @Date: 2021/7/13
 * @Desc:
 * 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出和为目标值 target  的那 两个 整数，并返回它们的数组下标。
 * 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
 * 你可以按任意顺序返回答案。
 * 进阶：你可以想出一个时间复杂度小于 O(n^2) 的算法吗？
 *
 * 示例 1：
 * 输入：nums = [2,7,11,15], target = 9
 * 输出：[0,1]
 * 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
 *
 * 示例 2：
 * 输入：nums = [3,2,4], target = 6
 * 输出：[1,2]
 *
 * 示例 3：
 * 输入：nums = [3,3], target = 6
 * 输出：[0,1]
 */
public class TwoSum {
    public static void main(String[] args) {
        int[] nums = {3,2,4};
//        int[] nums = {3,3};
        int target = 6;
        int[] ints = twoSum(nums, target);
        for (int anInt : ints) {
            System.out.println(anInt);
        }
    }

    private static int[] twoSum(int[] nums, int target) {
        if(null == nums || nums.length < 2){
            return null;
        }
        // 误区 不能全部插入
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            if(map.containsKey(target - nums[i])){
                // 当前值为nums[i] map里面已经有满足条件的值
                return new int[]{map.get(target - nums[i]), i};
            }
            map.put(nums[i], i);
        }
        return null;
    }
}
```

## 2021/07/13 两数相加（中等）

```java
package com.lcl.study.practice.likou;

import java.math.BigInteger;
import java.util.Stack;

/**
 * @Auther: licl
 * @Description: 两数相加
 * @Date: 2021/7/14
 * @Desc:
 * 给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。
 * 请你将两个数相加，并以相同形式返回一个表示和的链表。
 * 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。
 * 实例1：
 * 输入：l1 = [2,4,3], l2 = [5,6,4]
 * 输出：[7,0,8]
 * 解释：342 + 465 = 807.
 *
 * 示例 2：
 * 输入：l1 = [0], l2 = [0]
 * 输出：[0]
 *
 * 示例 3：
 * 输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
 * 输出：[8,9,9,9,0,0,0,1]
 *
 * 提示：
 * 每个链表中的节点数在范围 [1, 100] 内
 * 0 <= Node.val <= 9
 * 题目数据保证列表表示的数字不含前导零
 *
 */
public class AddTwoNumbers {
    public static class ListNode {
        int val;
        ListNode next;

        ListNode() {
        }

        ListNode(int val) {
            this.val = val;
        }

        ListNode(int val, ListNode next) {
            this.val = val;
            this.next = next;
        }
    }

    public static void main(String[] args) {
        ListNode h11 = new ListNode(2);
        ListNode h12 = new ListNode(4);
        ListNode h13 = new ListNode(3);
        h11.next = h12;
        h12.next = h13;

        ListNode h21 = new ListNode(5);
        ListNode h22 = new ListNode(6);
        ListNode h23 = new ListNode(4);
        h21.next = h22;
        h22.next = h23;
        // 方法1 暴力解法 反转 -> 整型 -> 相加 -> 再反转
//        ListNode listNode = addTwoNumbers1(h11, h21);
        // 方法2  最优解，按位相加
        ListNode listNode = addTwoNumbers(h11, h21);
        while (listNode != null){
            System.out.println(listNode.val);
            listNode = listNode.next;
        }
    }

    private static ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        if(null == l1 && null == l2){
            return null;
        }
        // 进位
        int carry = 0;
        ListNode head = null;
        ListNode res = null;
        while (null != l1 || null != l2){
            if(null == l1) l1 = new ListNode(0);
            if(null == l2) l2 = new ListNode(0);
            int sum = (l1.val + l2.val) + carry;
            int num = sum % 10;
            carry = sum / 10;
            ListNode next = new ListNode();
            next.val = num;
            if(null == head){
                head = next;
                res = head;
            } else {
                head.next = next;
                head = head.next;
            }
            l1 = l1.next;
            l2 = l2.next;
        }
        if(carry != 0){
            // 添加进位到链表尾 val一定为1
            head.next = new ListNode(1);
        }
        return res;
    }

    public static ListNode addTwoNumbers1(ListNode l1, ListNode l2) {
        // 1.定义一个反转链表的方法
        StringBuilder sb1 = new StringBuilder();
        while (l1 != null){
            sb1.append(l1.val);
            l1 = l1.next;
        }
        StringBuilder sb2 = new StringBuilder();
        while (l2 != null){
            sb2.append(l2.val);
            l2 = l2.next;
        }
        BigInteger l1r = new BigInteger(reverse(sb1.toString()));
        BigInteger l2r = new BigInteger(reverse(sb2.toString()));
        BigInteger sum = l1r.add(l2r);
        String sumStr = sum.toString();
        String reverse = reverse(sumStr);
        ListNode res = new ListNode();
        ListNode head = res;
        char[] chars = reverse.toCharArray();
        res.val = Integer.parseInt(String.valueOf(chars[0]));
        for (int i = 1; i < chars.length; i++) {
            ListNode listNode = new ListNode();
            listNode.val = Integer.parseInt(String.valueOf(chars[i]));
            res.next = listNode;
            res = res.next;
        }
        return head;
    }

    private static String reverse(String str) {
        Stack<String> stack = new Stack<>();
        for (char c : str.toCharArray()) {
            stack.push(String.valueOf(c));
        }
        StringBuilder sb = new StringBuilder();
        while (!stack.isEmpty()){
            sb.append(stack.pop());
        }
        return sb.toString();
    }
}

```

## 2021/07/19 无重复字段的最长子串（中等）

```JAVA
package com.lcl.study.practice.likou;

import java.util.LinkedList;
import java.util.List;

/**
 * @Auther: licl
 * @Description: 无重复字符的最长子串
 * @Date: 2021/7/19
 * @Desc:
 *
 * 给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。
 *
 * 示例 1:
 *
 * 输入: s = "abcabcbb"
 * 输出: 3
 * 解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
 * 示例 2:
 *
 * 输入: s = "bbbbb"
 * 输出: 1
 * 解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
 * 示例 3:
 *
 * 输入: s = "pwwkew"
 * 输出: 3
 * 解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
 *      请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
 * 示例 4:
 *
 * 输入: s = ""
 * 输出: 0
 *  
 *
 * 提示：
 *
 * 0 <= s.length <= 5 * 104
 * s 由英文字母、数字、符号和空格组成
 *
 */
public class LengthOfLongestSubstring {

    public int lengthOfLongestSubstring(String s) {
        if(null == s || "".equals(s) || s.length() == 0) return 0;
        List list = new LinkedList();
        char[] chars = s.toCharArray();
        int size = 0;
        for (int i = 0; i < chars.length; i++) {
            char aChar = chars[i];
            if (!list.contains(aChar)){
                list.add(aChar);
            } else {
                // 找到当前重复元素的上一个位置
                int index = list.indexOf(aChar);
                if(list.size() > index){
                    for (int j = index; j >= 0; j--) {
                        list.remove(j);
                    }
                }
                list.add(aChar);
            }
            size = list.size() > size ? list.size() : size;
        }
        return size;
    }

    public static void main(String[] args) {
        String str = "bpfbhmipx";
        LengthOfLongestSubstring obj = new LengthOfLongestSubstring();
        System.out.println(obj.lengthOfLongestSubstring(str));
    }

}

```

## 2021/07/20 最长回文子串（中等）

```java
package com.lcl.study.practice.likou;

import java.util.*;

/**
 * @Auther: licl
 * @Description: 最长回文子串
 * @Date: 2021/7/20
 * @Desc:
 * 给你一个字符串 s，找到 s 中最长的回文子串。

 * 示例 1：
 * 输入：s = "babad"
 * 输出："bab"
 * 解释："aba" 同样是符合题意的答案。
 *
 * 示例 2：
 * 输入：s = "cbbd"
 * 输出："bb"
 * 示例 3：
 *
 * 输入：s = "a"
 * 输出："a"
 * 示例 4：
 *
 * 输入：s = "ac"
 * 输出："a"
 *
 * 提示：
 * 1 <= s.length <= 1000
 * s 仅由数字和英文字母（大写和/或小写）组成
 *
 */
public class LongestPalindrome {
    // 暴力解法 枚举所有情况
    public String longestPalindrome(String s) {
        if ("".equals(s) || null == s || s.length() < 1) return "";
        int max = 0;
        String ans = "";
        int len = s.length();
        for (int i = 0; i < len; i++) {
            for (int j = i + 1; j < len + 1; j++) {
                String str = s.substring(i, j);
                if(isPalindrome(str) && str.length() > max){
                    ans = str;
                    max = Math.max(max, str.length());
                }
            }
        }
        return ans;
    }

    // 判断你是否为回文结构
    private boolean isPalindrome(String str) {
        Stack stack = new Stack();
        char[] chars = str.toCharArray();
        for (char aChar : chars) {
            stack.push(aChar);
        }
        StringBuilder sb = new StringBuilder();
        while (!stack.isEmpty()){
            sb.append(stack.pop());
        }
        if(str.equals(sb.toString())) return true;
        return false;
    }

    public static void main(String[] args) {
        String s = "a";
        LongestPalindrome longestPalindrome = new LongestPalindrome();
        System.out.println(longestPalindrome.longestPalindrome(s));
    }
}

```

# 2021/07/23 打印二叉树前、中、后序遍历结果

```java

```

